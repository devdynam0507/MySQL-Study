MySQL 5.7 버전부터 지원되기 시작한 데이터 암호화 기능은 처음에는 데이터 파일(테이블스페이스)에 대해서만 암호화 기능이 제공됐다.  
그러나 MySQL 8.0으로 업그레이드 되면서 데이터 파일뿐만 아니라 리두 로그나 언두 로그, 복제를 위한 바이너리 로그 등도 모두 암호화 기능을 지원하기 시작했다.  
데이터 암호화 여부는 보안 감사에서 필수적으로 언급되는 부분이며 핀테크 서비스처럼 중요한 정보를 저장하는 서비스에서는 응용 프로그램에서 암호화한 데이터를 데이터베이스 서버에  
다시 암호화 하는 이중 암호화 방법을 선택하기도 한다.  
응용 프로그램의 암호화는 주로 중요 정보를 가진 컬럼 단위로 암호화를 수행하며 데이터베이스 수준에서는 테이블 단위로 암호화를 적용한다
## MySQL 서버의 데이터 암호화
MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰기 지점에서 암호화 또는 복호화를 수행한다.  
그래서 MySQL 서버에서 디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요치 않다.  
즉 MySQL 서버(InnoDB 스토리지 엔진)의 I/O 레이어에서만 데이터 암호화 및 복호화 과정이 실행되는 것이다.  
MySQL 서버에서 사용자의 쿼리를 처리하는 과정에서 테이블의 데이터가 암호화돼 있는지 여부를 식별할 필요가 없으며 암호화된 테이블도 그렇지 않은 테이블과  
동일한 처리 과정을 거친다.  
데이터 암호화 기능이 활성화돼 있다고 하더라도 MySQL 내부의 사용자 입장에서는 아무런 차이가 없기 때문에 이러한 암호화 방식을 가리켜 TDE(Transparent Data Encryption) 라고 한다.  
또한 Data at Rest Encryption 이라고도 하는데 여기서  Data at Rest는 메모리나 네트워크 전송 단계가 아닌 디스크에 저장된 단계에서만 암호화 된다는 의미로 사용된다는 표현이다.  
## 2단계 키 관리
MySQL 서버의 TDE에서 암호화 키는 키링 플러그인에 의해 관리되며 MySQL 8.0 버전에서 지원되는 키링 플러그인은 다음과 같다.  
하지만 MySQL 커뮤니티 에디션에서는 keyring_file 플러그인만 사용 가능하고 나머지 플러그인은 모두 MySQL 엔터프라이즈 에디션에서만 사용 가능하다.  
- keyring_file File-Based 플러그인
- keyring_encrypted_file Keyring 플러그인
- keyring_okv KMIP 플러그인
- keyring_aws Amazon Web Services Keyring 플러그인
다양한 플러그인이 제공되지만 마스터 키를 관리하는 방법만 다를 뿐 MySQL 서버 내부적으로 작동하는 방식은 모두 동일하다.  
MySQL 서버의 키링 플러그인 2단계 키 관리 방식을 사용한다.  
MySQL 서버의 데이터 암호화는 마스터 키와 테이블 스페이스 키 라는 두 가지 종류의 키를 가지고 있는데 테이블스페이스 키는 프라이빗 키 라고도 한다.  
MySQL 서버는 HashiCorp Vault 같은 외부 키 관리 솔루션 또는 디스크의 파일에서 마스터 키를 가져오고 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블 스페이스 키를 발급한다.  
그리고 MySQL 서버는 마스터 키를 이용해 테이블스페이스 키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장한다.  
이렇게 생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않는다.  
하지만 테이블 스페이스 키는 절대 MySQL 서버 외부로 노출되지 않기 때문에 테이블스페이스 키를 주기적으로 변경하지 않아도 보안상 취약점이 되지는 않는다.  
마스터 키를 변경하면 MySQL 서버는 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화한다.  
MySQL 서버에서 이렇게 2단계 암호화 방식을 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위함이다.  
테이블스페이스 키가 변경된다면 MySQL 서버는 데이터 파일의 모든 데이터를 다시 복호화했다가 다시 암호화해야 한다.  
이로 인해 키를 변경할 떄마다 엄청난 작업을 해야 하며 사용자 쿼리를 처리하는 데도 상당한 영향을 미치게 된다.  
MySQL 서버의 TDE에서 지원되는 암호화 알고리즘은 AES 256비트이며 이외의 알고리즘은 지원되지 않는다.  
테이블 스페이스 키는 AES-256 ECB 알고리즘을 이용해 암호화 되고 실제 데이터 파일은 AES-256 CBC 알고리즘을 이용해 암호화 된다.  
## 암호화와 성능
MySQL 서버의 암호화는 TDE 방식이기 때문에 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재된다.  
그래서 데이터 페이지가 한 번 메모리에 적재되면 암호화 되지 않은 테이블과 동일한 성능을 보인다.  
하지만 쿼리가 InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우에는 복호화 과정을 거치기 떄문에 복호화 시간 동안 쿼리 처리가 지연될 것이다.  
그리고 암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화 돼야하기 때문에 디스크에 저장할 때도 추가로 시간이 더 걸린다.  
하지만 데이터 페이지 저장은 사용자의 쿼리를 처리하는 스레드가 아닌 MySQL 서버의 백그라운드 스레드가 수행하기 때문에 실제 사용자 쿼리가 지연되는 것은 아니다.  
AES 암호화 알고리즘은 암호화 하고자 하는 평문의 길이가 짧은 경우 암호화 키의 크기에 따라 암호화된 결과의 용량이 더 커질 수도 있지만  
이미 데이터 페이지는 암호화 키보다 훨씬 크기 때문에 암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환한다.  
같은 테이블에 대해 암호화와 압축이 동시에 적용되면 MySQL 서버는 압축을 먼저 실행하고 암호화를 적용한다.  
압축이 암호화보다 먼저 실행되는 이유는 다음과 같다.  
- 일반적으로 암호화된 결과는 아주 랜덤한 바이트의 배열을 가지게 되는데 이는 압축률을 상당히 떨어뜨린다. 그래서 최대한 압축 효율을 높이기 위해 사용자의 데이터를 그대로 압축해서 용량을 최소화 한 후 암호화를 적용한다.  
- 또한 암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만 압축된 데이터 페이지는 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼 풀에 존재할 수 있다. 그래서 암호화가 먼저 실행되고 압축이 적용된다면 MySQL 서버는 InnoDB 버퍼 풀에 존재하는  
- 데이터 페이지에 대해서도 매번 암복호화 작업을 수행하면 된다.  
암호화된 테이블은 디스크 읽기가 그렇지 않은 테이블보다 3~5배 정도 느리고 쓰기의 경우 5~6배 정도 느리다.  
## keyring_file 플러그인 설치
MySQL 서버의 데이터 암호화 기능인 TDE의 암호화 키 관리는 플러그인 방식으로 제공된다.  
MySQL 엔터프라이즈 에디션에서 사용할 수 있는 플러그인은 다양하지만 MySQL 커뮤니티 에디션에서는 keyring_file 플러그인만 가능하다.  
여기서는 keyring_file 플러그인을 설치하고 사용하는 방법을 간단히 살펴보겠다.  
우선 keyring_file 플러그인은 테이블스페이스 키를 암호화 하기 위한 마스터 키를 디스크의 파일로 관리하는데 이떄 마스터 키는 평문으로 디스크에 저장된다.  
즉 마스터 키가 저장된 파일이 외부에 노출된다면 데이터 암호화는 무용지물이 된다.  
## 테이블 암호화
키링 플러그인은 마스터 키를 생성하고 관리하는 부분까지만 담당하기 때문에 어떤 키링 플러그인 사용하든 관계없이 암호화된 테이블을 생성하고 활용하는 방법은 모두 동일하다.
### TDE를 이용하는 테이블 생성
```SQL
CREATE TABLE tab_enc(
    id INT,
    dat VARCHAR(100),
    PRIMARY KEY(id)
) ENCRYPTION='Y';
```
일반적인 테이블 생성 구문과 동일하며 ENCRYPTION='Y' 옵션만 추가로 넣으면 된다.  
## 언두 로그 및 리두 로그 암호화
테이블의 암호화를 적용하더라도 디스크로 저장되는 데이터만 암호화되고 MySQL 서버의 메모리에 존재하는 데이터는 복호화된 평문으로 관리되며 이 평문 데이터가 테이블의 데이터 파일 이외의 디스크 파일로  
기록되는 경우에는 여전히 평문으로 저장된다.  
그래서 테이블 암호화를 적용해도 리두 로그나 언두 로그 그리고 복제를 위한 바이너리 로그에는 평문으로 저장되는 것이다.  
MySQL 8.0.16 부터는 innodb_undo_log_encrypt 시스템 변수와 innodb_redo_log_encrypt 시스템 변수를 이용해 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있게 개선됐다.  
## 바이너리 로그 암호화
일반적으로 언두 로그와 리두 로그는 길지 않은 시간 동안의 데이터만 가지기 때문에 크게 보안에 민감하지 않을 수 있지만 바이너리 로그는 의도적으로 상당히 긴 시간동안 보관하는 서비스도 있고 때로는 증분 백업을 위해  
바이너리 로그를 보관하기도 한다.  
이런 이유로 바이너리 로그 파일의 암호화는 상황에 따라 중요도가 높아질 수 있다.  
바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고 MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터  
를 암호화 하지는 않는다.  
레플리케이션 멤버간의 네트워크 구간에서도 바이너리 로그를 암호화 하고자 한다면 MySQL 복제를 위한 계정이 SSL을 사용하도록 설정하면 된다.  
복제시 네트워크 구간으로 전송되는 데이터의 암호화에 대해서는 '사용자 및 권한'을 참고하자.
## mysqlbinlog
MySQL 서버에서는 트랜잭션의 내용을 추적하거나 백업 복구를 위해 암호화된 바이너리 로그를 평문으로 복호화할 일이 자주 발생한다.  
하지만 한 번 바이너리 로그 파일이 암호화 되면 바이너리 로그 암호화 키가 없으면 복호화할 수 없다.  
