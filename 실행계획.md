# 실행계획
## 통계 정보
MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행계획을 수립했다.  
하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다.  
그래서 MySQL 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.  
히스토그램이 도입됐다고 해서 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아니다.  
여기서는 테이블 및 인덱스에 대한 통계 정보와 히스토그램을 나누어 살펴보겠다.  
### 테이블 및 인덱스 통계 정보
비용 기반 최적화에서 가장 중요한 것은 통계 정보다.  
통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다.  
예를들어 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 레코드가 10건 미만인 것처럼 돼있다면 옵티마이저는 실제 쿼리를 실행할 때 인덱스레인지 스캔이 아니라 테이블을 처음부터 끝까지 읽는 방식으로 실행해 버릴 수도 있다.  
부정확한 통계 정보 탓에 0.1초에 끝날 쿼리에 1시간이 소요될 수도 있다.  
MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용하지만, 다른 DBMS 보다 통계 정보의 정확도가 높지 않고 통계 정보의 휘발성이 강했다.  
그래서 MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 이룹 분석해서 통계 정보를 보완해서 사용했다.  
이러한 이유로 MySQL 5.6 버전부터는 통계 저옵의 정확성을 높일 수 있는 방법ㅇ ㅣ제공되기 시작했지만 아직도 많은 사용자가 기존 방식을 그대로 사용한다.  
여기서는 MySQL 8.0 버전에서 통계 정보 관리가 어덯게 개선됐는지도 함께 살펴본다.  
### MySQL 서버의 통계 정보
5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다.  
5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고 SHOW INDEX 명령으로만 테이블의 인덱스 칼럼의 분포도를 볼 수 있었다.  
이처럼 통계 정보가 메모리에 관리될 경우 MySQL 서버가 재시작되면 지금까지 수집된 통계 정보가 모두 사라진다.  
5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_indesx_status 테이블과 innodb_table_stats 테이블로 관리할 수 있게 개선됐다.  
이렇게 통계 정보를 테이블로 관리함으로써 MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 됐다.  
### 히스토그램
5.7 버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값이 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다.  
그래서 옵티마이저는 이러한 부족함을 메우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다.  
8.0 버전으로 업그레이드되면서 MySQL 서버도 드디어 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 됐다.  
### 히스토그램의 용도
MySQL 서버에 히스토그램이 도입되기 이전에도 테이블과 인덱스에 대한 통계 정보는 존재했다.  
하지만 기존 MySQL 서버가 가지고 있던 통계 정보는 테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값이 개수 정도였다.  
예를 들어 테이블의 레코드가 1000건이고 어떤 칼럼의 유니크한 값 개수가 100개였다면 MySQL 서버는 이 칼럼에 대해 다음과 같은 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측한다.  
```sql
SELECT * FROM order WHERE user_id='matt.le';
```
하지만 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다.  
어떤 사용자는 주문 레코드를 많이 가지고 있고 또 다른 사용자는 아예 없을 수도 있다.  
그렇지만 MySQL 서버의 기존 통계 정보는 이런 부분을 고려하지 못했다.  
이러한 단점을 보완하기 위해 히스토그램이 도입됐다.  
히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위별로 레코드의 건수와 유니크한 값이 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.  
간단히 employees 테이블의 birth_date 칼럼에 대해 히스토그램이 없을 때와 히스토그램이 있을 때의 예측치가 얼마나 달라지는지 한 번 살펴보자.  
다음 예제의 결과를 보면 옵티마이저는 first_name = 'Zita' 조건에 일치하는 레코드가 224건이 있고 그중에서 대략 11.11%인 24.8명 정도의 birth_date가 1950년대 출생일 것으로 예측했다.  
히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.  
하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.  
이게 무슨 큰 변화냐고 반문할 수도 있는데, 이는 쿼리의 성능에 상당한 영향을 미칠 수 있다.  
### 히스토그램과 인덱스
히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만.  
MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느 정도 공통점을 가진다고 볼 수 있다.  
MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.  
이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다.  
이 작업을 매뉴얼에서는 인덱스 다이브 라고 표현한다.  
쿼리의 검색 조건으로 많이 사용되는 칼럼에 대해서는 일반적으로 인덱스를 생성한다.  
그런데 이렇게 인덱스된 칼럼에 대해 히스토그램 정보를 수집해 두는 것이 좋을지 고민스러울 수 있다.  
```sql
SELECT * FROM employees 
WHERE first_name='Tonny'
AND birth_date BETWEEN '1954-01-01' AND '1955-01-01';
```
옵티마이저는 테이블 풀 스캔을 할지 first_name 칼럼의 인덱스를 이용할지 고민할 것이다.  
birth_date 칼럼은 실행 계획에 큰 영향을 미치지 않을 것이다.  
first_name 칼럼에 히스토그램이 수집돼 있었다면 MySQL 옵티마이저는 그 히스토그램을 이용하게 될까?  
MySQL 8.0 서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우 그 칼럼의 히스토그램은 사용하지 않고  
실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.  
이는 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다.  
그래서 MySQL 8.0 버전에서 히스토그램은 주로 **인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도**로 사용한다.  
하지만 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는 (IN 절에 값이 많이명시된 경우) 실행 계획 수립 만으로도 상당한 인덱스 다이브를 실행하고  
비용도 그만큼 커진다.  
아마 조만간 실제 인덱스 다이브를 실행하기보다는 히스토그램을 활용하는 최적화 기능도 MySQL 서버에 추가되지 않을까 생각된다.  
### 코스트 모델
MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.  
- 디스크로부터 데이터 페이지 읽기
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업
MySQL 서버는 사용자의 쿼리에 대해 이러한 다야한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행계획을 찾는다.  
이렇게 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델 이라고 한다.  
MySQL 5.7 이전 버전까지는 이런 작업들의 비용을 MySQL 서버 소스 코드에 상수화해서 사용했다.  
하지만 이 작업들의 비용은 MySQL 서버가 사용하는 하드웨어에 따라 달라질 수 있기 때문에 예전 버전처럼 고정된 비용을 일률적으로 적용하는 갓은 최적의 실행 계획 수립에 있어서 방해 요소였다.  
이런 단점을 보완하기 위해 MySQL 5.7 버전부터 Mysql 서버의 소스코드에 상수화돼 있던 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있게 개선됐다.  
하지만 MySQL 5.7 버전에서 인덱스되지 않은 칼럼의 데이터분포(히스토그램)나 메모리에 상주중인 페이지의 비율 등 비용 계산과 연관된 부분의 정보가 부족한 상태였다.  
MySQL 8.0 버전으로 업그레이드 되면서 비로소 칼럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용되기 시작했다.  
MySQL 8.0 서버의 코스트 모델은 다음 2개 테이블에 저장돼 있는 설정값을 사용하는데, 두 테이블 모두 mysql DB에 존재한다.  
- server_cost: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- engine_cost: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
server_cost 테이블과 engione_cost 테이블은 공통으로 다음 5개의 컬럼을 가지고 있다.  
참고로 last_updated와 comment 칼럼의 값은 MySQL 서버 옵티마이저에 영향을 미치는 정보는 아니며 단순 정보성으로 관리되는 칼럼이다.  
- cost_name: 코스트 모델의 각 단위 작업
- default_value: 각 단위 작업의 비용
- cost_value: DBMS 관리자가 설정한 값
- last_updated: 단위 작업의 비용이 변경된 시점
- comment: 비용에 대한 추가 설명  
engine_cost 테이블은 위의 5개 칼럼에 추가로 다음 2개 칼럼들 더 가지고 있다.  
- engine_name: 비용이 적용된 스토리지 엔진
- device_type: 디스크 타입  
engine_name 칼럼은 스토리지 엔진별로 각 단위 작업의 비용을 설정할 수 있는데 기본값은 "default"다 여기서 "default"는 특정 스토리지 엔진의 비용이 설정되지 않았다면 해당 스토리지 엔진의 비용으로 이 값을 적용한다는 의미다.  
MEMORY 스토리지 엔진, 그리고 MyISAM과 InnoDB 스토리지 엔진에 대해 단위 작업의 비용을 달리 설정하고자 한다면 engine_name 칼럼을 이용하면 된다.  
device_type은 디스크의 타입을 설정할 수 있는데 MySQL 8.0에서는 아직 이 칼럼의 값을 활용하지는 않는다.  
그래서 8.0 버전에서는 0만 설정할 수 있다.  
8.0 버전의 코스트 모델에서 지원하는단위 작업은 다음과 같이 8개다.  
### engine_cost  
io_block_read_cost - 1.00 - 디스크 데이터 페이지 읽기  
memory_block_read_count - 0.25 - 메모리 데이터 페이지 읽기  
### server_cost
disk_temptable_create_cost - 20.00 - 디스크 임시 테이블 생성  
disk_temptable_row_cost - 0.50 - 디스크 임시 테이블의 레코드 읽기  
key_compare_cost - 0.05 - 인덱스 키 비교  
memory_temptable_create_cost - 1.00 - 메모리 임시 테이블 생성  
memory_temptable_row_cost - 0.10 - 메모리 임시 테이블의 레코드 읽기  
row_evaluate_cost - 0.10 - 레코드 비교  
row_evaluate_cost는 스토리지 엔진이 반환한 레코드가 쿼리의 조건에 일치하는지를 평가하는 단위 작업을 의미하는데 row_evaluate_cost 값이 증가할수록  
풀 테이블 스캔과 같이 많은 레코드를 처리하는 쿼리의 비용이 높아지고 반대로 레인지 스캔과 같이 상대적으로 적은 수의 레코드를 처리하는 쿼리의 비용이 낮아진다.  
key_compare_cost는 키 값의 비교 작업에 필요한 비용을 의미하는데, key_compare_cost 값이 증가할수록 레코드 정렬과 같이 키 값 비교 처리가 많은 경우 쿼리의 비용이 높아진다.  
각 단위 작업의 비용을 이용해 MySQL 서버의 실행 계획에 표시되는 비용을 직접 계산해보고 싶을 수도 있다.  
하지만 역으로 이러한 계산을 직접 해보기는 쉽지 않다.  
대표적으로 MySQL 옵티마이저는 인덱스의 B-Tree 깊이와 인덱스 키 검색을 위해 읽어야 하는 페이지의 개수, 그리고 디스크와 메모리(InnoDB 버퍼풀)에서 데이터페이지를 각각 몇 개씩 읽어야 하는지, 또는 레코드 정렬 작업에서 사용되는 알고리즘별로 키 값 비교 작업이 몇 번 필요한지 등을 이용해 쿼리의 비용이 계산된다.  
코스트 모델에서 중요한 것은 각 단위작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것이다.  
대표적으로 각 단위 작업의 비용이 변경되면 예상할 수 있는 결과들은 다음과 같다. 물론 다음 예시가 MySQL 서버 옵티마이저의 실행 계획에 미치는 영향의 전부는 아니지만 대략 코스트 모델을 이해하고 각 단위 작업의 비용 조절을 연습해 볼 수 있는 기준은 될 것이다.  
- key_compare_cost 비용을 높이면 MySQL 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.  
- row_evaluate_cost 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 늘어나고 MySQL 옵티마이저는 가능하면 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.  
- disk_temptable_create_cost와 dis_temptable_row_cost 비용을 높아면 MySQL 옵티마이저는 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.  
- memory_temptable_create_cost와 memory_temptable_row_cost 비용을 높이면 MySQL 서버 옵티마이저는 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.  
- io_block_read_cost 비용이 높아지면 MySQL 서버 옵티마이저는 가능하면 InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.  
- memory_block_read_cost 비용이 높아지면 MySQL 서버는 InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.  
## 실행 계획 확인
MySQL 서버의 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인할 수 있다.  
# 실행 계획 분석
실행 계획에 표시되는 각 칼럼이 어떤 것을 의미하는지, 그리고 각 칼럼에 어떤 값들이 출력될 수 있는지 하나씩 자세히 살펴보겠다.  
## id 칼럼
하나의 SELECT 문장은 다시 1개 이상의 하위 SELECT 문장을 포함할 수 있다. 다음 쿼리를 살펴보자.  
```sql
SELECT ...
FROM (SELECT ... FROM tb_test1) tb1, tb_test2 tb2
WHERE tb1.id=tb2.id;
```
위의 쿼리 문장에 있는 각 SELECT를 다음과 같이 분리해서 생각해볼 수 있다.  
이렇게 SELECT 키워드 단위로 구분한 것을 단위 쿼리 라고 표현하겠다.  
```sql
SELECT ... FROM tb_test;
SELECT ... FROM tb1, tb_test2 tb2 WHERE tb1.id=tb2.id;
```
실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. 이 예제 쿼리의 경우 실행 계획에서 최소  
2개의 id 값이 표시될 것이다. 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여된다.  
다음 예제에서처럼 SELECT 문장은 하나인데, 여러 개의 테이블이 조인되는 경우 id 값이 증가하지 않고 같은 id 값이 부여된다.  
```sql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no LIMIT 10;
```
반대로 다음 쿼리의 실행 계획에서는 쿼리 문장이 3개의 단위 SELECT 쿼리로 구성돼 있으므로 실행 계획의 각 레코드가 각기 다른 id 값을 지닌 것을 확인할 수 있다.  
```sql
EXPLAIN
SELECT (SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments) AS total_count;
```
여기서 한가지 주의해야 할 것은 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다는 것이다.  
다음 쿼리의 실행 계획을 살펴보면 dept_emp 테이블의 id 값은 1이고 employees 테이블의 id 값은 2로 표시됐다.  
### select_type 칼럼
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. select_type 칼럼에 표시될 수 있는 값은 다음과 같다.  
#### SIMPLE 
UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 select_type은 SIMPLE로 표시된다.(쿼리에 조인이 포함된 경우에도 마찬가지다.)  
쿼리 문장이 아무리 복잡하더라도 실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 하나만 존재한다. 일반적으로 제일 바깥 SELECT의 select_type이 SIMPLE로 표시된다.  
#### PRIMARY
UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리는 select_type이 PRIMARY로 표시된다.  
SIMPLE과 마찬가지로 select_type이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMAR로 표시된다.  
#### UNION 
UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type은 UNION으로 표시된다.  
UNION의 첫 번째 단위 SELECT는 select_tyoe이 UNION이 아니라 UNION 되는 쿼리 결과들을 모아서 저장하는 임시 테이블 (DERIVED이 selec_type으로 표시된다.  
```sql
EXPLAIN
SELECT * FROM (
    (SELECT emp_no FROM employees e1 LIMIT 10) UNION ALL
    (SELECT emp_no FROM employees e2 LIMIT 10) UNION ALL
    (SELECT emp_no FROM employees e3 LIMIT 10) tb;
)
```
위 쿼리의 실행 계획은 UNION이 되는 단위 SELECT 쿼리 3개중에서 첫 번째 (e1 테이블)만 UNION이 아니고 나머지 2개는 모두 UNION으로 표시돼 있다.  
대신 UNION이 첫번째 쿼리는 전체 UNION의 결과를 대표하는 select_type으로 설정됐다.  
여기서는 세 개의 서브쿼리로 조회된 결과를 UNION ALL 로 결합해 임시 테이블을 만들어서 사용하고 있으므로 UNION ALL 의 첫번째 쿼리는 DERIVED 라는 select_type을 갖는 것이다.  
#### DEPENDENT UNION
DEPENDENT UNION 또한 UNION select_type과 같이 UNION 이나 UNION_ALL 로 집합을 결합하는 쿼리에서 표시된다.  
그리고 여기서 DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.  
#### UNION RESULT
UNION RESULT 는 UNION 결과를 담아두는 테이블을 의미한다.  
#### SUBQUERY
FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.  
#### DEPENDENT SUBQUERY
서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우, select_type에 DEPENDENT SUBQUERY라고 표시된다.  
#### DERIVED
5.5 버전까지는 서브쿼리가 FROM 절에 사용된 경우 항상 select_type이 DERIVED 실행 계획을 만든다.  
5.6버전 부터는 옵티마이저 옵션에 따라 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다.  
#### DEPENDENT DERIVED
8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 칼럼을 사용할 수가 없었는데, MySQL 8.0 버전부터는 레터럴 조인 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 됐다.  
#### UNCACHEABLE SUBQUERY
하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.  
그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전에 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다.  
여기서 언급하는 서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능이므로 혼동하지 않도록 주의하자.  
간단히 SUBQUERY와 DEPENDENT SUBQUERY가 캐시를 사용하는 방법을 비교해보자.  
- SUBQUERY는 바깥쪽의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.  
- DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 칼럼의 값 단위로 캐시해두고 사용한다.  
#### UNCACHEABLE UNION
이미 UNION과 UNCACHEABLE에 대해서는 충분히 설명했으므로 기본적인 의미는 이해했을 것이다. UNCACHEABLE UNION이란 이 두 개 키워드의 속성이 혼합된 select_type을 의미한다.  
#### MATERIALIZED
5.6 버전부터 도입된 select_type으로 주로 FROM 절이나 IN 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.  
다음 쿼리는 급여가 100보다 크거나 같고 1000보다 작거나 같은 직원들의 정보를 모두 가져오는 쿼리다.  
```sql
EXPLAIN
SELECT *
FROM employees e
WHERE e.emp_no IN (SELECT emp_no FROM salaries WHERE salary BETWEEN 100 AND 1000);
```
5.6 버전까지는 employees 테이블을 읽어서 employees 테이블의 레코드마다 salaries 테이블을 읽는 서브쿼리가 실행되는 형태로 처리됐다.  
5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화 한 후 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.  
### table 칼럼
MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다.  
테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.  
간단한 예제 쿼리를 살펴보자.  
```sql
EXPLAIN SELECT NOW();
EXPLAIN SELECT NOW() FROM DUAL;
```
첫 번째 쿼리는 FROM 절 자체가 없으며 두번쨰 쿼리는 FROM 절에 DUAL 이라는 테이블이 사용됐다.  
실제 DUAL 이라는 테이블은 없지만 이 쿼리는 오류를 발생시키지 않는다.  
오라클 RDBMS에 익숙한 사용자를 위해 MySQL 서버는 내부적으로 DUAL 이라는 테이블이 있는거처럼 작동할 뿐이다.  
실제로 MySQL 옵티마이저는 두 번째 쿼리가 요청되면 from dual 부분을 제거하고 첫 번째 쿼리와 동일하게 변형해서 처리한다.  
오라클 RDBM에서는 FROM 절이 없으면 오류가 발생하지만 MySQL 서버는 그렇지 않다.  
위의 두 예제와 같이 별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우에는 table 칼럼에 NULL이 표시된다.  
table 칼럼에 derived N 또는 union M,N 과 같이 <> 로 둘러싸인 이름이 명시되는 경우가 많은데, 이 테이블은 임시 테이블을 의미한다.  
또한 <> 안에는 항상 표시되는 숫자 단위는 SELECT 쿼리의 id값을 지칭한다.  
### partitions 칼럼
5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록은 EXPLAION PARTITION 명령을 이용해 확인 가능했지만 MySQL 8.0 버전부터는 EXPLAIN 명령으로 파치션 관련 실행 계획까지 모두 확인할 수 있게 변경 됐다.  
### type 칼럼
쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.  
여기서 방식이라 함은 인덱스를 사용해 레코드를 읽었는지, 아니면 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 레코드를 읽었는지 등을 의미한다.  
일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행 계획에서 type 칼럼은 반드시 체크해야할 중요한 정보다.  
MySQL 메뉴엘에서는 type 칼럼을 조인 타입으로 소개한다.  
또한 MySQ에서는 하나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리한다.  
그래서 SELECT 쿼리의 테이블 개수에 관계없이 실행 계획의 type 컬럼을 조인 타입이라고 명시하고 있다.  
하지만 type 칼럼의 값은 조인과 직접 연관 지어 생각하지 말고, 각 테이블의 접근 방법으로 해석하면 된다.  
실행 계획의 type 칼럼에 표시될 수 있는 값은 현재 많이 사용되는 대부분의 버전에서 거의 차이 없이 다음과 같이 표시된다.  
- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subquery
- index_subquery
- range
- index_merge
- index
- ALL
위의 12개의 접근 방법 중에서 ALL 을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다.  
AL은 인덱스를 사용하지 않고 테이블을 처음부터 끝까지 읽어서 레코드를 가져오는 풀 테이블 스캔 접근 방법을 의미한다.  
하나의 단위 SELECT 쿼리는 위의 접근 방법 중에서 단 하나만 사용할 수 있다.  
또한 index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다.  
그러므로 실행 계획의 각 라인에 접근 방법이 2개 이상 표시되지 않으며, index_merge 이외의 type에서는 인덱스 항목에도 단 하나의 인덱스 이름만 표시된다.  
이제 실행 계획의 type 칼럼에 표시될 수 있는 값을 위의 순서대로 하나씩 살펴보자.  
참고로 위에 표시된 각 접근 방법은 성능이 빠른 순서대로 나열된 것이며, 각 type의 설명도 이 순서대로 진행할 것이다.  
MySQL 옵티마이저는 이러한 접근 방법과 비용을 함께 계산해서 최소의 비용이 필요한 접근 방법을 선택해 쿼리를 처리한다.  
### system
레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 system이라고 한다.  
이 접근 방법은 InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고,  
MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.  
```sql
CREATE TABLE tb_dual (fd1 int NOT NULL) ENGINE = MyISAM;
INSERT INTO tb_dual VALUES(1);

EXPLAIN SELECT * FROM tb_dual;
```
위 예제에서 tb_dual 테이블은 레코드가 1건만 들어있는 MyISAM 테이블이다.  
이 테이블을 InnoD로 변환하면 결과는 어떻게 될까?  
쿼리의 모양마다 조금 다르겠지만 type 칼럼이 ALL 또는 index로 표시될 가능성이 크다. system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있는 접근방법 이므로 실제 애플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.  
### const
테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 방식을 const라고 한다. 다른 DBMS 에서는 이를 유니크 인덱스 스캔이라고 한다.  
### eq_ref
eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.  
조인에서 처음 읽은 테이블의 칼럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때를 가리켜 eq_ref라고 한다.  
이떄 두 번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시된다. 또한 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL 이어야 하며 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용돼야만 eq_ref 접근 방법이 사용될 수 있다.  
즉, 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.  
다음 예제 쿼리의 실행 계획을 살펴보자.  
우선 첫 번째 라인과 두 번째 라인의 id 값이 1로 같으므로 두개의 테이블이 조인으로 실행된다는 것을 알 수있다.  
그리고 dept_emp 테이블이 실행 계획의 위쪽에 있으므로 dept_emp 테이블을 먼저 읽고 e.emp_no=de.emp_no 조건을 이용해 employees 테이블을 검색한다.  
employees 테이블의 emp_no는 프라이머리 키라서 실행 계획의 두 번째 라인은 type 칼럼이 eq_ref로 표시된다.  
```sql
EXPLAIN
SELECT * from DEPT_EMP DE, EMPOYEES E
WHERE e.emp_no=de.emp_no and de.dept_no='d005';
```
### ref
ref 접근 방법은 eq_ref와 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키등의 제약 조건도 없다.  
인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref 접근 방법이사용된다. ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref 보다는 빠르지 않다.  
하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.  
```sql
EXPLAIN 
SELECT * FROM dept_emp WHERE dept_no='d005';
```
위의 예에서는 dept_emp 테이블의 프라이머리 키를 구성하는 칼럼(dept_no, emp_no)중에서 일부만 동등 조건으로 WHERE 절에 명시됐기 때문에  
레코드가 1건이라는 보장이 없다. 그래서 const가 아닌 ref 접근 방법이 사용됐으며 실행 계획의 ref 칼럼값에는 const가 명시됐다.  
이 const는 접근 방법이 아니라 ref 접근 방법에서 값 비교에 사용된 입력값이 상수 였음을 의미한다.  
ref 칼럼의 내용은 뒤에서 다시 한번 살펴보겠다.  
지금까지 배운 실행 계획의 type에 대해 간단히 비교하면서 다시 한번 정리해보자  
- const: 조인의 순서와 관계없이 프라이머리 키나 유니크 키의 모든 칼럼에 대해 동등 조건으로 검색 (반드시 1건의 레코드만 반환)
- eq_req: 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번쨰 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색  
- ref: 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색(1건의 데이터가 검색된다는 보장이 없어도 됨)  
이 3가지 방법은 매우 좋은 접근 방법으로 인덱스의 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는 접근 방법이다.  
쿼리를 튜닝할 때도 이 세가지 접근 방법에 대해서는 크게 신경 쓰지 않고 넘어가도 무방하다.  
### fulltext
fulltext 접근 방법은 MySQ 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.  
지금 살펴보는 type의 순서가 일반적인 처리 성능의 순서이긴 하지만 실제로 데이터의 분포나 레코드 건수에 따라 빠른 순서는 달라질 수 있다.  
이는 비용 기반의 옵티마이저에서 통계 정보를 이용해 비용을 계산하는 이유이기도 하다. 하지만 전문 검색 인덱스는 통계 정보가 관리되지 않으며,  
전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야한다.  
### ref_or_null
이 접근 방법은 ref 접근 방법과 같은데 NULL 비교가 추가된 형태다. 접근 방법의 이름 그대로 ref 방식 또는 NULL 비교 접근 방법을 의미한다.  
실제 업무에서 많이 활용되지 않지만, 만약 사용된다면 나쁘지 않은 접근 방법 정도로 기억해두면 충분하다.  
### unique_subquery
WHERE 조건절에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방법이다.  
unique_subquery의 의미그대로 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.  
### index_subquery
IN 연산자의 특성상 IN(subquery) 또는 IN(상수 나열) 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다.  
앞서 살펴본 unique_subquery 접근방법은 IN(subquery) 조건의 subquery가 중복된 값을 만들어내지 않는다는 보장이 있으므로 별도의 중복을 제거할 필요가 없었다.  
하지만 업무 특성상 IN(subquery)에서 subquery가 중복된 값을 반환할 수도 있다.  
이때 서브쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 index_subquery 접근 방법이 사용된다.  
명확한 이해를 위해 index_subquery와 unique_subquery 접근 방법의 차이를 다시 한번 정리해 보자.  
- unique_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음  
- index_subquery: IN (subquery) 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 갑슬 제거할 수 있음  
### range
range는 우리가 익히 알고있는 인덱스 레인지 스캔 형태의 접근 방법이다.  
range는 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미하는데 주로 <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 떄 사용된다.  
일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법인데  
이 책에서 소개하는 접근 방법의 순서상 MySQL 서버가 가지고 있는 접근 방법 중에서 상당히 우선순위가 낮다는 것을 알 수있다.  
얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다.  
### index_merge
지금까지 설명한 다른 접근 방법과는 달리 index_merge 접근 방법은 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.  
하지만 index_merge 접근 방법이 사용되는 경우를 생각해보면 이름만큼 그렇게 효율적으로 작동하는 것은 아니다.  
index_merge 접근 방법에는 다음과 같은 특징이 있다.  
- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.  
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지는 않는다.  
- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.  
### index
index 접근 방법은 많은 사람이 자주 오해하는 접근 방법이다. 접근 방법의 이름이 index라서 MySQL 서버에 익숙하지 않은 많은 사람이 "효율적으로 인덱스를 사용하는구나"라고 생각하게 만드는것 같다.  
하지만 index 접근 방법은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다.  
range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아니라는 점을 잊지 말자.  
index 접근 방법은 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다.  
하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔 시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 훨씬 효율적이라 할 수 있다. index 접근 방법은 다음 조건 가운데 (1 + 2) 조건을 충족 하거나 (1 + 3)조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.  
- range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
- 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼링니 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)  
- 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우(즉, 별도의 정렬 작업을 피할 수 있는 경우)
다음 쿼리는 아무런 WHERE 조건이 없으므로 range나 const 또는 ref 접근 방법을 사용할 수 없다.  
하지만 정렬하려는 칼럼은 인덱스(ux_deptname)가 있으므로 별도의 정렬 처리를 피하려고 index 접근 방법을 사용했다.  
### ALL
우리가 흔히 알고 있는 테이블 풀 스캔을 의미하는 접근 방법이다.  
테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거(체크 조건이 존재할 때)하고 반환한다.  
풀 테이블 스캔은 지금까지 설명한 접근 방법으로는 처리할 수 없을 때 가장 마지막에 선택하는 가장 비효율적인 방법이다.  
다른 DBMS와 같이 InnoDB도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 IO 를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어 들이는 기능을 제공한다 InnoDB에서는 이 기능을 리드 어헤드라고 하며 한 번에 여러 페이지를 읽어서 처리할 수 있다.  
## possible_keys 칼럼
실행 계획에 있는 이 칼럼 또한 사용자의 오해를 자주 불러일으킨다.  
MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을  
선택해 쿼리를 실행한다. 그런데 possible_keys 칼럼에 있는 내용은 옵티마이저가 최적의 실행 게획을 만들기 위해 후보로 선정했던 접근 방법에서  
사용되는 인덱스의 목록일 뿐이다.  
즉, 말 그대로 "사용될 법했던 인덱스의 목록" 인것이다.  
실제로 실행 계획을 보면 그 테이블의 모든 인덱스가 목록에 포함되어 나오는 경우가 허다하기에 쿼리를 튜닝하는데 크게 도움이 되지는 않는다.  
그래서 실행 계획을 확인할 때는 possible_keys 칼럼은 특별한 경우를 제외하고는 그냥 무시해도된다.  
## key 칼럼
possible_keys가 칼럼의 인덱스 사용 후보였던 반면, key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.  
그러므로 쿼리를 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는것이 중요하다.  
key 칼럼에 표시되는 값이 PRIMARY인 경우에는 프라이머리 키를 사용한다는 의미이며 그 이외의 값은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름이다.  
실행 계획의 type 칼럼이 index_merge가 아닌 경우에는 반드시 테이블 하나당 하나의 인덱스만 이용할 수 있다.  
하지만 index_merge 실행 계획이 사용될 때는 2개 이상의 인덱스가 사용되는데  
이때는 key 칼럼에 여러 개의 인덱스가 ,로 구분되어 표시된다.  
앞에서 살펴본 index_merge 실행 계획을 다시 한번 살펴보자.  
## key_len 칼럼
key_len 칼럼은 많은 사용자가 쉽게 무시하는 정보지만 사실은 매우 중요한 정보 중 하나다.  
실제 업무에서 사용되는  테이블은 단일 칼럼으로만 만들어진 인덱스보다 다중 칼럼으로 만들어진 인덱스가 더 많다.  
실행 계획의 key_len 칼럼의 값은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려주는 값이다.  
더 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다. 그래서 다중 칼럼 인덱스뿐 아니라 단일 칼럼으로 만들어진 인덱스에서도 같은 지표를 제공한다.  
## ref 칼럼
접근 방법이 ref면 참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다. 상숫값을 지정했다면 ref 칼럼의 값은 const로 표시되고  
다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다.  
이 칼럼에 출력되는 내용은 크게 신경 쓰지 않아도 무방한데, 다음과 같은 케이스는 조금 주의해서 볼 필요가 있다.  
가끔 쿼리의 실행 계획에서 ref 칼럼의 값이 func라고 표시될 때가 있다. 이는 Function의 줄임말로 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜리에션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.  
간단히 다음 예제 쿼리의 실행 계획을 한번 살펴보자.  
```sql
EXPLAIN SELECT *
FROM employees e, dept_emp de
WHERE e.emp_no=de.emp_no;
```
이 쿼리는 employees 테이블과 dept_emp 테이블을 조인하는데, 조인 조건에 사용된 emp_no 칼럼의 값에 대해 아무런 변환이나 가공도 수행하지 않았다.  
그래서 이 쿼리의 실행 계획은 다음과 같이 ref 컬럼에 조인 대상 칼럼의 이름이 그대로 표시된다.  
이번에는 위의 쿼리에서 조인 조건에 간단한 산순 표현식을 넣어 쿼리를 만들고 실행 계획을 한번 확인해 보자  
```sql
EXPLAIN
SELECT *
FROM Memployees e, dept_emp de WHERE e.emp_no=(de.emp_no-1);
```
위의 쿼리에서는 dept_emp 테이블을 읽어서 emp_no 값에서 1을 뺀 값으로 employees 테이블과 조인한다.  
이 쿼리의 실행 계획에서는 ref 값이 조인 컬럼의 이름이 아니라 func 라고 표시되는 것을 확인할 수 있다.  
## rows 칼럼
MySQL 옵티마이저는 각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 비교해 최종적으로 하나의 실행 계획을 수립한다.  
이때 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해서 비용을 산정한다.  
대상 테이블에 얼마나 많은 레코드가 포함돼 있는지 또는 각 인덱스 값의 분포도가 어떤지를 통계 정보를 기준으로 조사해서 예측한다.  
MySQ 실행 계획의 rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.  
이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.  
또한 rows 칼럼에 표시되는 값은 반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미한다.  
그래서 실행 계획의 rows 칼럼에 출력되는 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많다.  
## filtered 칼럼
옵티마이저는 각 테이블에서 일치하는 레코드 개수를 가능하면 정확히 파악해야 좀 더 효율적인 실행 계획을 수립할 수 있다.  
실행 계획에서 rows 칼럼의 값은 인덱스를 사용하는 조건ㄴ에만 일치하는 레코드 건수를 예측한 것이다.  
하지만 대부분의 쿼리에서 WHERE 절에 사용되는 조건이 모두 인덱스를 사용할 수 있는 것은 아니다.  
특히 조인이 사용되는 경우에는 WHERE 절에서 인덱스를 사용할 수 있는 조건도 중요하지만 인덱스를 사용하지 못하는 조건에 일치하는 레코드 건수를 파악하는 것도 매우 중요하다.  
## Extra 칼럼
칼럼의 이름과는 달리, 쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시된다.  
Extra 칼럼에는 고정된 몇 개의 문장이 표시되는데, 일반적으로 2~3개씩 함께 표시된다.  
Extra 칼럼에는 주로 내부적인 처리 알고리즘에 대해 깊이 있는 내용을 보여주는 겨웅가 많다.  
### const row not found
쿼리의 실행 계획에서 const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않으면 Extra 칼럼에서 이 내용이 표시된다.  
Extra 칼럼에 이런 메시지가 표시되는 경우에는 테이블에 적절히 테스트용 데이터를 저장하고 다시 한번 쿼리의 실행 계획을 확인해 보는 것이 좋다.  
### Deleting all rows
MyISAM 스토리지 엔진과 같이 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진 테이블인 경우  
Extra 칼럼에 Deleting all rows문구가 표시된다.  
### Distinct
테이블에서 중복없이 유니크하게 값을 가져오기 위해 DISTINCT 를 사용하는 경우 보여진다.  
쿼리의 DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 필요한 것만 조인했으며, 테이블에서 꼭 필요한 레코드만 읽었다는 것을 표현하고 있다.  
### FirstMatch
세미 조인의 여러 최적화 중에서 FirstMatch 전략이 사용되면 MySQL 옵티마이저는 실행 계획의 Extra 칼럼에 FirstMatch(table_name)메시지를 출력한다.  
FirstMatch 메시지에 함께 표시되는 테이블명은 기준 테이블을 의미하는데 table_name을 기준으로 드리븐 테이블에서 첫 번째로 일치하는 한 건만 검색한다는 것을 의미한다.  
### Full scan on NULL key
이 처리는 col1 IN (SELECT col2 FROM ...) 과 같은 조건을 가진 쿼리에서 자주 발생할 수 있는데 col1의 값이 NULL이 된다면 결과적으로 조건은  
NULL IN (SELECT col2 FROM ...) 과 같이 바뀐다.  
SQL 표준에서는 NULL을 알 수 없는 값으로 정의하고 있으며 NULL 에 대한 연산의 규칙까지 정의하고 있다.  
fuLL SCAN ON null key 코멘트가 실행 계획의 Extra 칼럼에 표시됐다고 하더라도 IN 이나 NOT IN 연산자의 왼쪽에 있는 값이 실제로 NULL이 없다면  
tb_test2 테이블에 대한 풀 테이블 스캔은 발생하지 않으니 걱정하지 않아도 된다.  
### Impossible HAVING
쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 실행 계획의 Extra 칼럼에는 Impossible HAVING 키워드가 표시된다.  
```sql
EXPLAIN
SELECT e.em_no, COUNT(*) as cnt
FROM employees e
WHERE e.emp_no=10001
GROUP BY e.emp_no
HAVING e.emp_no IS NULL;
```
위 예제에서 HAVING 조건에 e.emp_no IS NULL 이라는 조건이 추가됐지만 사실 employees 테이블의 e.emp_no 컬럼은 프라이머리 키 이면서 NOT NULL 타입의 컬럼이다.  
그러므로 결고 e.emp_no IS NULL 조건을 만족할 가능성이 없으므로 Extra 칼럼에서 Impossible HAVING 이라는 키워드를 표시한다.  
애플리케이션의 쿼리중에서 실행 계획의 Extra 칼럼에 Impossible HAVING 메시지가 출력된다면 쿼리가 제대로 작성되지 못한 경우가 대부분이므로 쿼리의 내용을 다시 한번 점검해보는 것이 좋다.  
### Impossible WHERE
Impossible HAVING 과 비슷하며 WHERE 조건이 항상 false 가 될 수 밖에 없는 경우 Impossible WHERE가 표시된다.  
```sql
EXPLAIN
SELECT * FORM employees WHERE emp_no IS NULL;
```
emp_no 컬럼이 notnull 컬럼이라고 치면 위 쿼리는 emp_no is NULL 은 항상 FALSE 가 된다.  
### LooseScan
세미 조인 최적화 중에서 LooseScan 최적화 전략이 사용되면 실행 계획의 Extra 칼럼에는 LooseScan 문구가 표시된다.  
### No matching min/max row
쿼리의 WHERE 조건절을 만족하는 레코드가 한 건도 없는 경우 일반적으로 Impossible WHERE 문장이 표시된다.  
MIN() 이거나 MAX()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때는 Extra 칼럼에 No matching min/max row 라는 메시지가 출력된다.  
그리고 MIN() 이나 MAX()의 결과로 NULL이 반환된다.  
### no matcinh row in const table
다음 쿼리와 같이 조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없다면 no matcing row in const table 이라는 메시지를 표시한다.  
```sql
EXPLAIN
SELECT * FROM dept_emp de,
(SELECT emp_no FROM employees WHERE emp_no=0) tb1,
WHERE tb1.emp_no=de.emp_no AND de.dept_no='d005';
```
### No matcinh rows after partition pruning
No matcinh rows after partition pruning 메시지는 파티션된 테이블에 대한 UPDATE 또는 DELETE 명령의 실행 계획에서 표시될 수 있는데,  
해당 파티션에서 UPDATE 하거나 DELETE 할 대상 레코드가 없을 때 표시된다.  
### No tables used
FROM 절에 없는 쿼리 문장이나 FROM DUAL 형태의 쿼리 실행 계획에 대해서는 Extra 칼럼에 No tables used
가 표시된다.  
### Not exists
프로그램을 개발하다보면 a 테이블에는 존재하지만 b 테이블에는 없는 값을 조회해야 하는 쿼리가 자주 사용된다.  
이럴 때는 주로 NOT IN (subquery) 형태나 NOT EXISTS 연산자를 주로 사용한다.  
이런 형태의 조인을 안티 조인 이라고 한다.  
똑같은 처리를 아우터 조인을 이용 해서도 구현할 수 있다.  
일반적으로 NOT IN(subquery)나 NOT EXISTS 등의 연산자를 사용하는 안티 조인으로 처리해야 하지만 레코드의 건수가 많을때는 아우터 조인을 사용하면 빠른 성능을 낼 수 있다.  
### Plan isn't ready yet
8.0 버전에서는 다음과 같이 다른 커넥션에서 실행 중인 쿼리의 실행 계획을 살펴볼 수 있다.  
```sql
SHOW PROCESSLIST;

EXPLAIN FOR CONNECTION 8;
```
이 상태에서 다른 커넥션에서 employees 테이블을 읽고 있는 이 쿼리의 실행 계획을 EXPLAIN FOR CONNECTION 명령으로 확인해보자.  
실제 커넥션 id가 8인 커넥션에서 실행하고 있는 쿼리의 실행계획을 살펴본 결과 정말 풀 테이블 스캔을 실행하고 있다는 것을 알 수 있다.  
EXPLAIN FOR CONNECTION 명령은 MySQL 옵티마이저가 의도된 인덱스를 사용하지 못해서 풀 스캔을 한다거나 잘못된 실행 계획을 선택한 것이 아닌지 확인할 때 유용하게 사용할 수 있는 명령이다.  
그래서 Plan isn't ready yet 이라는 메세지는 해당 커넥션이 아직 실행계획을 수립하지 못했다는 것을 의미한다.  

### Range checked for each record(index map: N)
두 개의 테이블을 조인하는 다음의 쿼리를 보면서 이 메시지의 의미를 이해해 보자.  
조인 조건에 상수가 없고 둘 다 변수(e1.emp_no와 e2.emp_no)인 경우 MySQL 옵티마이저는 e1 테이블을 먼저 읽고 조인을 위해 e2를 읽을 때 인덱스 레인지 스캔과 풀 테이블 스캔 중에서 어느것이 효율적일지 판단할 수 없게 된다.  
즉 e1 테이블의 레코드를 하나씩 읽을 때 마다 e1.emp_no 값이 계속 바뀌므로 쿼리의 비용 계산을 위한 기준 값이 계속 변하는 것이다.  
그래서 어떤 접근 방법으로 e2 테이블을 읽는 것이 좋을지 판단할 수 없다.  
```sql
EXPLAIN
SELECT *
FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no;
```
예를 들어 사번이 1번부터 1억번까지 있다고 가정해보자.  
그러면 e1 테이블을 처음부터 끝까지 스캔하면서 e2 테이블에서 e2.emp_no >= e1.emp_no 조건을 만족하는 레코드를 찾아야 하는데 문제는  
e1.emp_no=1 인 경우에는 e2 테이블의 1억건 전부를 읽어야 한다는 것이다.  
하지만 e1.emp_no=100000000인 경우에는 e2 테이블을 한건만 읽으면 된다.  
그래서 e1 테이블의 emp_no가 작을 때는 e2 테이블을 풀 테이블 스캔으로 접근하고 e1 테이블의 emp_no가 큰 값을 때는 e2 테이블을 인덱스 레인지 스캔으로 접근하는 형태를 수행하는 것이 최적의 조인 방법이다.  
지금까지 설명한 내용을 줄여서 설명하면 레코드마다 인덱스 레인지 스캔을 체크한다 라고 할 수 있는데 이것이 Extra 칼럼에 표시되는 Range checked for each record의 의미다.  
Extra 칼럼의 출력 내용중에서 indexmap: N은 사용할지 말지를 판단하는 후보 인덱스의 순번을 나타낸다.  
index map은 16진수로 표시되는데 해석을 위해서는 우선 이진수로 표현을 바꿔줘야 한다.  
만약 indexmap: 0x1 이라고 표시가 됬다면 이걸 이진수로 바꿔도 1이다. 그래서 이 쿼리는 해당 테이블의 첫번째 인덱스를 사용할지 아니면 테이블을 풀 스캔할지 레코드 단위로 결정하면서 처리된다.  
indexmap에 표시된 후보 인덱스를 사용할지 여부를 검토하면서 이 후보가 별로 도움이 되지 않는다면 최종적으로 풀 테이블 스캔을 사용하기 때문에 ALL로 표시된 것이다.  
### Recursive
8.0버전부터는 CTE(Common Table Expression)을 이용해 재귀 쿼리를 작성할 수 있게 됐다.  
MySQL 서버에서 재귀 쿼리는 다음 예제와 같이 WITH 구문을 이용해 CTE를 사용하면 된다.  
```sql
WITH RECURSIVE cte (n) AS
    (
        select 1
        UNION ALL
        SELECT n + 1 FROM cte WHERE n < 5
    )
    SELECT * FROM cte;
```
1. n이라는 컬럼 하나를 가진 cte 라는 이름의 내부 임시 테이블을 생성
2. n 칼럼의 값이 1부터 5까지 1씩 증가하게 해서 레코드 5건을 만들어서 cte 내부 임시 테이블에 저장
그리고 WITH 절 다음의 SELECT 쿼리에서는 WITH 절에서 생성된 내부 임시 테이블을 풀 스캔해서 결과를 반환한다.  
이렇게 CTE를 이용한 재귀 쿼리의 실행 계획은 Extra 칼럼에 Recursive 구문이 표시된다.  
### Rematerialize
8.0부터는 래터럴 조인 기능이 추가됐는데 이 경우 래터럴로 조인되는 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시 테이블에 저장한다.  
이 과정을 Rematerializing 이라고 한다.  
### Select tables optimized away
MIN() 또는 MAX()만 SELECT 절에 사용되거나 GROUP BY로 MIN(), MAX() 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용된다면 Extra 칼럼에 SELECT tables optimized away가 표시된다.  
### Start temporary, End temporary
세미 조인 최적화 중에서 Duplicate weed-out 최적화 전략이 사용되면 MySQL 옵티마이저는 다음 예제와 같이 실행 계획의 Extra 칼럼에 Start temporary와 End temporary 문구를 표시하게 된다.  
Duplicate Weed-out 최적화 전략은 불필요한 중복 건을 제거하기 위해서 내부 임시 테이블을 사용하는데, 이때 조인되어 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게 조인의 첫 번째 테이블에 Start temporary 문구를 보여주고 조인이 끝나는 부분이 End temporary 문구를 표시해준다.  
### unique row ot found
두 개의 테이블이 각각 유니크(프라이머리 키 포함) 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 떄 Extra 칼럼에 이 코멘트가 표시된다.  
### Using filesort
ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는 MySQL 서버가 조회된 레코드를 다시 한번 정렬해야 한다.  
ORDER BY 처리가 인덱스를 사용하지 못할 때만 실행 계획에 Extra 칼럼에 Using filesort 코멘트가 표시되며, 이는 조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행하게 된다는 의미다.  
실행 계획 Extra 칼럼에 Using filesort 가 나온다면 이는 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.  
### Using index (커버링 인덱스)
데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 Extra 칼럼에 Using index가 표시된다.  
인덱스를 이용해 처리하는 쿼리에서 가장 큰 부하를 차지하는 부분은 인덱스 검색에서 일치하는 키 값들의 레코드를 읽기 위해 데이터 파일을 검색하는 작업이다.  
최악의 경우에는 인덱스를 통해 검색된 결과 레코드 한 건 한 건마다 디스크를 한 번씩 읽어야 할 수도 있다.  
InnoDB의 모든 테이블은 클러스터링 인덱스로 구성돼 있다. 그리고 이 때문에 InnoDB 테이블의 모든 세컨더리 인덱스는 데이터 레코드의 주솟값으로 프라이머리 키 값을 가진다.  
InnoDB 테이블에서는 어떤 한 칼럼으로 인덱스를 만들어도 결국 그 인덱스에 프라이머리 칼럼이 같이 저장되는 효과를 낸다.  
이러한 클러스터링 인덱스 특성 때문에 쿼리가 커버링 인덱스로 처리될 가능성이 상당히 높다.  
### Using index condition
MySQL 옵티마이저가 인덱스 컨디션 푸시다운 최적화를 사용하면 Extra 칼럼에 Using index condition 메세지가 표시된다.  
### Using index for group-by
GROUP BT 처리를 위해 MySQL 서버는 그루핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그루핑 하는 형태의 고부하 작업을 필요로 한다.  
하지만 GROUP BY 처리가 인덱스(B-Tree 인덱스에 한해서)를 이용하면 별도의 추가 정렬 작업 없이 정렬된 인덱스 칼럼을 순서대로 읽으면서 그루핑 작업만 수행한다.  
이렇게 GROUP BY 처리에 인덱스를 이용하면 레코드의 정렬이 필요하지 않고 인덱스의 필요한 부분만 읽으면 되기 때문에 상당히 효율적이고 빠르게 처리된다.  
### 타이트 인덱스 스캔을 통한 GROUP BY 처리
인덱스를 이용해 GROUP BY 절을 처리할 수 있더라도 AVG(), SUM(), COUNT() 처럼 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬성 듬성 읽을 수가 없다.  
이러한 쿼리는 단순히 GROUP BY를 위해 인덱스를 사용하기는 하지만 이를 루스 인덱스 스캔이라고 하지느 않는다.  
또한 이러한 쿼리의 실행 계획에는 Using index for group-by 메세지가 출력되지 않는다.  
### 루스 인덱스 스캔을 통한 GROUP BY 처리
단일 칼럼으로 구성된 인덱스에서는 그루핑 칼럼 말고는 아무것도 조회하지 않는 쿼리에서 루스 인덱스 스캔을 사용할 수 있다.  
그리고 다중 칼럼으로 만들어진 인덱스에서는 GROUP BY 절이 인덱스를 사용할 수 있어야 함은 물론이고 MIN()이나 MAX() 같이 조회하는 값이 인덱스의 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리는 루스 인덱스 스캔이 사용될 수 있다. 이때는 인덱스를 듬성듬성하게 필요한 부분만 읽는다.  
### Using index for skip scan
MySQL 옵티마이저가 인덱스 스킵 스캔 최적화를 사용하면 다음 예제와 같이 Extra 칼럼에 Using index for skip scan 메시지를 표시한다.  
```sql
ALTER TABLE employees ADD INDEX ix_gender_birthdate(gender, birth_date);

EXPLAIN
SELECT gender, birth_date FROM employees
WHERE birth_date >= '1965-02-01';
```
### Using join buffer(Block nested loop), Using join buffer(Batched Key Access), Using join buffer(hash join)
일반적으로 빠른 쿼리 실행을 위해 조인되는 칼럼은 인덱스를 생성한다.  
실제로 조인에 필요한 인덱스는 양쪽 테이블 칼럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 칼럼에만 필요하다.  
MySQL 옵티마이저도 조인되는 두 테이블에 있는 각 컬럼에서 인덱스를 조사하고 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행한다.  
뒤에 있는 테이블(드리븐 테이블)은 검색 위주로 사용되기 때문에 인덱스가 없으면 성능에 미치는 영향이 매우 크기 때문이다.  
  
조인이 수행될 때 드리븐 테이블의 조인 칼럼에 적잘한 인덱스가 있다면 아무런 문제가 되지 않는다.  
하지만 드리븐 테이블에 검색을 위한 적절한 인덱스가 없다면 MySQL 서버는 블록 네스티드 루프 조인이나 햇 ㅣ조인을 사용한다.  
블록 네스티드 루프 조인이나 해시 조인을 사용하면 Mysql 서버는 조인 버퍼를 사용한다.  
실행 계획에서 조인 버퍼가 사용되는 실행 계획의 Extra 칼럼에는 Using join buffer 라는 메세지가 표시된다.  
### Using MRR
MySQL 엔진은 실행 계획을 수립하고 그 실행 계획에 맞게 스토리지 엔진의 API를 호출해서 쿼리를 처리한다.  
InnoDB를 포함한 스토리지 엔진 레벨에서는 쿼리 실행의 전체적인 부분을 알지 못하기 때문에 최적화에 한계가 있다.  
이러한 이유로 아무리 많은 레코드를 읽는 과정이라 하더라도 스토리지 엔진은 MySQL 엔진이 넘겨주는 키 값을 기준으로 레코드를 한 건 한 건읽어서 반환하는 방식으로밖에 작동하지 못하는 한계점이 있다.  
실제 매번 읽어서 반환하는 레코드가 동일 페이지에 있다고 하더라도 레코드 단위로 API 호출이 필요한 것이다.  
MySQL 서버에서는 이 같은 단점을 보완하기 위해 MRR(Multi Range Read)라는 최적화를 도입했다.  
MySQL 엔진은 여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고 스토리지 엔진은 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화한다.  
MRR이 도입되면서 각 스토리지 엔진은 디스크 접근을 최소화할 수 있게 된다.  
### Using sort union(...), Using union(...), Using intersect(...)
쿼리가 index_merge 접근 방법으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있다.  
이때 실행 계획의 Extra 칼럼에는 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 조금 더 상세하게 설명하기 위해 다음 3개중 하나의 메시지를 선택적으로 출력한다.  
1. Using intersect(...): 각각의 인덱스를 사용할 수 있는 조건이 and로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했다는 의미다.  
2. Using union(...): 각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미다.  
3. Using sort_union(...): Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우 (OR로 연결된 상대적으로 대량의 range 조건들) 이 방식으로 처리된다. Using sort_union과 Using union의 차이점은 Using sort_union은 프라이머리 키만 먼저 읽어서 정렬하고 병합한 이후 비로소 레코드를 읽어서 반환할 수 있다는 것이다.  
Using union()과 Using sort_union()은 둘 다 충분히 인덱스를 사용할 수 있는 조건이 OR 연산자로 연결된 경우에 사용된다.  
레코드 건수에 상관없이 각 WHERE 조건에 사용된 비교 조건이 모두 동등 조건이면 Using union()이 사용되며 그렇지 않으면 Using sort_union()이 사용된다.  
### Using temporary
MySQL 서버에서 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용한다.  
임시 테이블은 메모리상에 생성될 수도 있고 디스크상에 생성될 수도 있다.  
쿼리의 실행 계획에서 Using temporary 가 표시되면 임시 테이블을 사용한 것인데 이때 사용된 임시 테이블이 메모리에 생성됐는지 디스크에 생성됐는지는 실행 계획만으로 판단할 수 없다.  
### Using where
이미 MySQL 서버의 아키텍처 부분에서 언급했듯 MySQL 서버는 내부적으로 크게 Mysql 엔진과 스토리지 엔진이라는 두 개의 레이어로 나눠 볼 수 있다.  
각 스토리지 엔진은 디스크나 메모리 상에서 필요한 레코드를 읽거나 저장하는 역할을 하며 MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행한다.  
MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에만 Extra 칼럼에 Using where 코멘트가 표시된다.  
```sql
EXPLAIN
SELET * FROM employees
WHERE emp_no BETWEEN 10001 and 10100
AND gender='F';
```
이 쿼리에서 작업 범위 결정 조건은 emp_no BETWEEN 10001 and 10100 이며 gender='F'는 체크 조건임을 쉽게 알 수 있다.  
그런데 처음에 emp_no 조건만 만족하는 레코드 건수는 100건이지만 두 조건을 모두 만족하는 레코드는 37건밖에 안된다.  
이는 스토리지 엔진에서 100건을 읽어서 MySQL 엔진에 넘겨줬지만 엔진은 그중에서 63건의 레코드를 그냥 필터링해서 버렸다는 의미다.  
여기서 Using where는 63건의 레코드를 버리는 처리를 의미한다.  
### Zero limit
때로는 MySQL 서버에서 데이터 값이 아닌 쿼리 결과값의 메타데이터만 필요한 경우도 있다.  
즉 쿼리의 결과가 몇 개의 컬럼을 가지고 각 컬럼의 타입이 무엇인지 등의 정보만 필요한 경우가 있다.  
이런 경우에는 쿼리의 마지막에 LIMIT 0 을 사용하면 되는데 이때 MySQL 옵티마이저는 사용자의 의도를 알아채고 실제 테이블의 레코드는 전혀 읽지 않고 결괏값의 메타 정보만 반환한다.  
이 경우 Zero limit이 출력된다 .