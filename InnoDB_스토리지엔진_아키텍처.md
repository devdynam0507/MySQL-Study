# InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL의 스토리지 엔진 가운데 가장 많이 사용된다.  
거의 유일하게 레코드 기반의 잠금을 제공하며 그 덕에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.  
![무제](https://user-images.githubusercontent.com/23313008/169311099-b5322517-a467-406b-a6ae-0e0609ff1b27.png)  
위 그림은 InnoDB의 아키텍처를 아주 간단히 보여주는데 각 부분에 관한 자세한 설명은 InnoDB 스토리지 엔진의 주요 특징들과 함께 하나씩 살펴보자.  
## 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 프라이머리 키 값의 순서대로 디스크에 저장된다.  
모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.  
프라이머리 키가 클러스터링 인덱스 이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.  
결과적으로 쿼리의 실행 계획에서 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.  
Oracle DBMS의 IOT(Index Organized Table)와 동일한 구조가 InnoDB에서는 일반적인 테이블 구조가 되는것이다.  
MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다.  
MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.  
## 외래 키 지원
- MyISAM 이나 Memory 테이블에서는 사용할 수 없다.
InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는  
작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는것이 좋다.  
수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다.  
부모 테이블과 자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제없이 실행할 수 있지만 외래 키가 복잡하게 얽힌 경우에는 그렇게 간단하지 않다.  
또한 서비스에 문제가 있어서 긴급하게 뭔가 조치를 해야하는데 이런 문제가 발생하면 더 조급해질 수도 있다.  
이런 경우에는 foreign_key_checks 시스템 변수를 OFF로 설정하면 외래 키에 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.  
외래키 체크를 일시적으로 해제했다고 해서 부모와 자식 테이블 간의 관계가 깨진 상태로 그대로 유지해도 된다는 것을 의미하지는 않는다.  
예를들어 외래 키 관계를 가진 부모 테이블의 레코드를 삭제했다면 반드시 자식 테이블의 레코드도 삭제해서 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화 해야한다.  
## MVCC (Multi Version Concurrency Control)
MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다.  
InnoDB는 언두 로그를 통해 이를 구현한다.  
여기서 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 말이다.  
이해를 위해 Isolation Level이 READ_COMMITED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 변경을 어떻게 처리하는지 그림으로 살펴보자.  
![무제](https://user-images.githubusercontent.com/23313008/169453662-cd167107-05a2-49fc-acd0-1b6acd819f29.png)  
먼저 Insert를 하게 되면 디비의 상테는 위와같이 바뀔 것이다.
여기서
```sql
UPDATE member SET area='경기' WHERE id=12
```
를 실행했을 땐  
![무제](https://user-images.githubusercontent.com/23313008/169453933-b4e5b83b-f96e-48fa-9600-51bc7df45946.png)  
위와같이 된다.
> area 컬럼의 변경 전 값만 언두 로그로 복사한다  
UPDATE가 실행되면 커밋 실행 여부와 상관 없이 InnoDB 버퍼 풀은 새로운 값인 '경기'로 업데이트 된다.  
그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 쓰레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.  
아직 COMMIT이나 ROLLBACK이 되지 않은 상황에서 다른 사용자가 다음 같은 쿼리로 작업중인 레코드를 조회하면 어디에 있는 데이터를 조회할까?  

```sql
SELECT * FROM member WHERE id = 12;
```
이것은 MySQL서버의 시스템 변수(transaction_isolation)에 설정된 Isolation Level에 따라 다르다.  
격리 수준이 READ_UNCOMMITED인 경우 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.  
그렇지 않고 READ_COMMITED나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우에는 아직 커밋되지 않았기 때문에  
InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.  
이러한 과정을 DBMS에서는 MVCC라고 표현한다.  
즉 하나의 레코드(회원 번호가 12인 레코드)에 대해 2개의 버전이 유지되고(하나는 InnoDB 버퍼풀 다른 하나는 언두 로그에 있는) 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조다.  
여기서는 한 개의 데이터만 가지고 설명 했지만 관리해야 하는 예전 버전의 데이터는 무한히 많아질 수 있다.  
정리하자면
1. UPDATE가 발생하게 되면 InnoDB 버퍼풀은 즉시 데이터 변경이 발생된다.  
2. 기존 데이터는 언두 영역으로 이동시킴
그러면 여기서 COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.  
하지만 롤백을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고 언두 영역의 내용을 삭제해버린다.  
커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니다. 이 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.  
> MVCC는 잠금을 걸지 않고 읽기 작업을 수행함
> 변경이 발생하면 InnoDB 버퍼풀로 즉시 반영되고 기존 데이터는 언두 영억으로 이동
> COMMIT 되면 언두 영역에 있는 백업 데이터는 삭제되고 더이상의 변경 작업 없이 영구적인 데이터로 만들어버림  
