# InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL의 스토리지 엔진 가운데 가장 많이 사용된다.  
거의 유일하게 레코드 기반의 잠금을 제공하며 그 덕에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.  
![무제](https://user-images.githubusercontent.com/23313008/169311099-b5322517-a467-406b-a6ae-0e0609ff1b27.png)  
위 그림은 InnoDB의 아키텍처를 아주 간단히 보여주는데 각 부분에 관한 자세한 설명은 InnoDB 스토리지 엔진의 주요 특징들과 함께 하나씩 살펴보자.  
## 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 프라이머리 키 값의 순서대로 디스크에 저장된다.  
모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.  
프라이머리 키가 클러스터링 인덱스 이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.  
결과적으로 쿼리의 실행 계획에서 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.  
Oracle DBMS의 IOT(Index Organized Table)와 동일한 구조가 InnoDB에서는 일반적인 테이블 구조가 되는것이다.  
MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다.  
MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.  
## 외래 키 지원
- MyISAM 이나 Memory 테이블에서는 사용할 수 없다.
InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는  
작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는것이 좋다.  
수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다.  
부모 테이블과 자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제없이 실행할 수 있지만 외래 키가 복잡하게 얽힌 경우에는 그렇게 간단하지 않다.  
또한 서비스에 문제가 있어서 긴급하게 뭔가 조치를 해야하는데 이런 문제가 발생하면 더 조급해질 수도 있다.  
이런 경우에는 foreign_key_checks 시스템 변수를 OFF로 설정하면 외래 키에 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.  
외래키 체크를 일시적으로 해제했다고 해서 부모와 자식 테이블 간의 관계가 깨진 상태로 그대로 유지해도 된다는 것을 의미하지는 않는다.  
예를들어 외래 키 관계를 가진 부모 테이블의 레코드를 삭제했다면 반드시 자식 테이블의 레코드도 삭제해서 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화 해야한다.  
